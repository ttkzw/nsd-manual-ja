# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001–2024, NLnet Labs
# This file is distributed under the same license as the NSD package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr "Project-Id-Version: NSD 4.3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-12 11:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/running/cookies.rst:2
msgid "DNS Cookies"
msgstr ""

#: ../../source/running/interfaces.rst:2
msgid "Interfaces"
msgstr ""

#: ../../source/running/interfaces.rst:4
msgid ""
"NSD will by default bind itself to the system default interface and "
"service IPv4 and if available also IPv6. It is possible to service only "
"IPv4 or IPv6 using the :option:`-4`, :option:`-6` command line options, "
"or the ``ip4-only`` and ``ip6-only`` config file options."
msgstr ""

#: ../../source/running/interfaces.rst:9
msgid ""
"The command line option :option:`-a` and config file option ip-address "
"can be given to bind to specific interfaces. Multiple interfaces can be "
"specified, which is useful for two reasons:"
msgstr ""

#: ../../source/running/interfaces.rst:13
msgid ""
"The specific interface bound will result in the OS bypassing routing "
"tables for the interface selection. This results in a small performance "
"gain. It is not the performance gain that is the problem: sometimes the "
"routing tables can give the wrong answer, see the next point."
msgstr ""

#: ../../source/running/interfaces.rst:17
msgid ""
"The answer will be routed via the interface the query came from. This "
"makes sure that the return address on the DNS replies is the same as the "
"query was sent to. Many resolvers require the source address of the "
"replies to be correct.  The ``ip-address:`` option is easier than "
"configuring the OS routing table to return the DNS replies via the "
"correct interface."
msgstr ""

#: ../../source/running/interfaces.rst:23
msgid ""
"The above means that even for systems with multiple interfaces where you "
"intend to provide DNS service to all interfaces, it is prudent to specify"
" all the interfaces as ``ip-address`` config file options."
msgstr ""

#: ../../source/running/interfaces.rst:27
msgid ""
"With the config file option ``ip-transparent`` you can allow NSD to bind "
"to non-local addresses."
msgstr ""

#: ../../source/running/logging.rst:2
msgid "Logging"
msgstr ""

#: ../../source/running/logging.rst:4
msgid ""
"NSD does not provide any DNS logging. We believe that this is a separate "
"task and has to be done independently from the core operation. This "
"consciously is not part of NSD itself in order to keep NSD focused and "
"minimise its complexity. It is better to leave logging and tracing to "
"separate dedicated tools."
msgstr ""

#: ../../source/running/logging.rst:9
msgid ""
"The `CAIDA dnsstat tool "
"<https://www.caida.org/catalog/software/dnsstat/>`_ can easily be "
"configured and/or modified to suit local statistics requirements without "
"any danger of affecting the name server itself. We have run ``dnsstat`` "
"on the same machine as NSD, and we would recommend using a multiprocessor"
" if performance is an issue. Of course, ``dnsstat`` can also run on a "
"separate machine that has MAC layer access to the network of the server."
msgstr ""

#: ../../source/running/logging.rst:16
msgid ""
"The :command:`nsd-control` tool can output some statistics, with :command"
":`nsd-control stats` and :command:`nsd-control stats_noreset`.  In "
"`contrib/nsd_munin_ "
"<https://github.com/NLnetLabs/nsd/blob/master/contrib/nsd_munin_>`_ there"
" is a Munin grapher plugin that uses it.  The output of :command:`nsd-"
"control stats` is easy to read (text only) with scripts.  The output "
"values are documented on the :command:`nsd-control` man page."
msgstr ""

#: ../../source/running/logging.rst:24
msgid ""
"Another available tool is `dnstop <http://dns.measurement-"
"factory.com/tools/dnstop/>`_, which displays DNS statistics on your "
"network."
msgstr ""

#: ../../source/running/tuning.rst:2
msgid "Tuning"
msgstr ""

#: ../../source/running/tuning.rst:4
msgid ""
"In version 4.3.0 of NSD, additional functionality was added to increase "
"performance even more. Most notably, this includes processor affinity."
msgstr ""

#: ../../source/running/tuning.rst:7
msgid ""
"NSD is performant by design because it matters when operators serve "
"hundreds of thousands or even millions of queries per second. We strive "
"to make the right choices by default, like enabling the use of "
"``libevent`` at the configure stage to ensure the most efficient event "
"mechanism is used on a given platform. e.g. ``epoll`` on Linux and "
"``kqueue`` on FreeBSD. Switches are available for operators who know the "
"implementation on their system behaves correctly, like enabling the use "
"of ``recvmmsg`` at the configure stage (:option:`--enable-recvmmsg`) to "
"read multiple messages from a socket in one system call."
msgstr ""

#: ../../source/running/tuning.rst:17
msgid ""
"By default NSD forks (only) one server. Modern computer systems however, "
"may have more than one processor, and usually have more than one core per"
" processor. The easiest way to scale up performance is to simply fork "
"more servers by configuring server-count: to match the number of cores "
"available in the system so that more queries can be answered "
"simultaneously. If the operating system supports it, ensure "
"``reuseport:`` is set to ``yes`` to distribute incoming packets evenly "
"across server processes to balance the load."
msgstr ""

#: ../../source/running/tuning.rst:25
msgid "A couple of other options that the operator may want to consider:"
msgstr ""

#: ../../source/running/tuning.rst:27
msgid ""
"Memory usage can be lowered (around 50%) by using zone files and disable "
"the on-disk database by setting ``database: \"\"``."
msgstr ""

#: ../../source/running/tuning.rst:29
msgid ""
"TCP capacity can be significantly increased by setting ``tcp-count: "
"1000`` and ``tcp-timeout: 3``. Set ``tcp-reject-overflow: yes`` to "
"prevent the kernel connection queue from growing."
msgstr ""

#: ../../source/running/tuning.rst:34
msgid "Processor Affinity"
msgstr ""

#: ../../source/running/tuning.rst:36
msgid ""
"The aforementioned settings provide an easy way to increase performance "
"without the need for in-depth knowledge of the hardware. For operators "
"that require even more throughput ``cpu-affinity`` is available."
msgstr ""

#: ../../source/running/tuning.rst:40
msgid ""
"The operating system’s scheduling-algorithm determines which core a given"
" task is allocated to. Processors build up state — e.g. by keeping "
"frequently accessed data in cache memory — for the task that it is "
"currently executing. Whenever a task switches cores, performance is "
"degraded because the core it switched to has yet to build up said state. "
"While this scheduling-algorithm works just fine for general-purpose "
"computing, operators may want to designate a set of cores for best "
"performance. The ``cpu-affinity`` family of configuration options was "
"added to NSD specifically for that purpose."
msgstr ""

#: ../../source/running/tuning.rst:49
msgid ""
"Processor affinity is currently supported on Linux and FreeBSD. Other "
"operating systems may be supported in the future, but not all operating "
"systems that can run NSD support CPU pinning. To fully benefit from this "
"feature, one must first determine which cores should be allocated to NSD."
" This requires some knowledge of the underlying hardware, but generally "
"speaking every process should run on a dedicated core and the use of "
"Hyper-Threading cores should be avoided to prevent resource contention. "
"List every core designated to NSD in ``cpu-affinity`` and bind each "
"server process to a specific core using ``server-<N>-cpu-affinity`` and "
"``xfrd-cpu-affinity`` to improve L1/L2 cache hit rates and reduce "
"pipeline stalls/flushes."
msgstr ""

#: ../../source/running/tuning.rst:70
msgid "Partition Sockets"
msgstr ""

#: ../../source/running/tuning.rst:72
msgid ""
"``ip-address:`` options in the ``server:`` clause can be configured per "
"server or set of servers. Sockets configured for a specific server are "
"closed by other servers on startup. This improves performance if a large "
"number of sockets are scanned using ``select/poll`` and avoids waking up "
"multiple servers when a packet comes in, known as the `thundering herd "
"problem <https://en.wikipedia.org/wiki/Thundering_herd_problem>`_. Though"
" both problems are solved using a modern kernel and a modern I/O event "
"mechanism, there is one other reason to partition sockets, explained "
"below."
msgstr ""

#: ../../source/running/tuning.rst:87
msgid "Bind to Device"
msgstr ""

#: ../../source/running/tuning.rst:89
msgid ""
"``ip-address:`` options in the server: clause can now also be configured "
"to bind directly to the network interface device on Linux "
"(``bindtodevice=yes``) and to use a specific routing table on FreeBSD "
"(``setfib=<N>``). These were added to ensure UDP responses go out over "
"the same interface the query came in on if there are multiple interfaces "
"configured on the same subnet, but there may be some performance benefits"
" as well as the kernel does not have to go through the network interface "
"selection process."
msgstr ""

#: ../../source/running/tuning.rst:102
msgid ""
"FreeBSD does not create extra routing tables on demand. Consult the "
"FreeBSD Handbook, forums, etc. for information on how to configure "
"multiple routing tables."
msgstr ""

#: ../../source/running/tuning.rst:107
msgid "Combining Options"
msgstr ""

#: ../../source/running/tuning.rst:109
msgid ""
"Field tests have shown best performance is achieved by combining the "
"aforementioned options so that each network interface is essentially "
"bound to a specific core. To do so, use one IP address per server "
"process, pin that process to a designated core and bind directly to the "
"network interface device."
msgstr ""

#: ../../source/running/tuning.rst:125
msgid ""
"The above snippet serves as an example on how to use the configuration "
"options. Which cores, IP addresses and routing tables are best used "
"depends entirely on the hardware and network layout. Be sure to test "
"extensively before using the options."
msgstr ""

#: ../../source/running/using-tsig.rst:2
msgid "Using Transaction Signature (TSIG)"
msgstr ""

#: ../../source/running/using-tsig.rst:4
msgid ""
"NSD supports Transaction Signature (TSIG) for zone transfer and for "
"notify sending and receiving, for any query to the server."
msgstr ""

#: ../../source/running/using-tsig.rst:7
msgid ""
"TSIG keys are based on shared secrets. These must be configured in the "
"config file. To keep the secret in a separate file use ``include: "
"\"filename\"`` to include that file."
msgstr ""

#: ../../source/running/using-tsig.rst:11
msgid "An example TSIG key named :file:`sec1_key`:"
msgstr ""

#: ../../source/running/using-tsig.rst:20
msgid ""
"This key can then be used for any query to the NSD server. NSD will check"
" if the signature is valid, and if so, return a signed answer. Unsigned "
"queries will be given unsigned replies."
msgstr ""

#: ../../source/running/using-tsig.rst:24
msgid ""
"The key can be used to restrict the access control lists, for example to "
"only allow zone transfer with the key, by listing the key name on the "
"access control line."
msgstr ""

#: ../../source/running/using-tsig.rst:35
msgid ""
"If the TSIG key name is used in ``notify`` or ``request-xfr`` lines, the "
"key is used to sign the request/notification messages."
msgstr ""

#: ../../source/running/zone-expiry.rst:2
msgid "Zone Expiry of Secondary Zones"
msgstr ""

#: ../../source/running/zone-expiry.rst:4
msgid ""
"NSD will keep track of the status of secondary zones, according to the "
"timing values in the SOA record for the zone. When the refresh time of a "
"zone is reached, the serial number is checked and a zone transfer is "
"started if the zone has changed. Each primary server is tried in turn."
msgstr ""

#: ../../source/running/zone-expiry.rst:9
msgid ""
"Master zones cannot expire so they are always served. Zones are "
"interpreted primary zones if they have no ``request-xfr:`` statements in "
"the config file."
msgstr ""

#: ../../source/running/zone-expiry.rst:12
msgid ""
"After the expire timeout (from the SOA record at the zone apex) is "
"reached, the zone becomes expired. NSD will return ``SERVFAIL`` for "
"expired zones, and will attempt to perform a zone transfer from any of "
"the primaries. After a zone transfer succeeds, or if the primary "
"indicates that the SOA serial number is still the same, the zone will be "
"OK again."
msgstr ""

#: ../../source/running/zone-expiry.rst:18
msgid ""
"In contrast with e.g. BIND, the inception time for a secondary zone is "
"stored on disk (in ``xfrdfile: \"xfrd.state\"``), together with timeouts."
" If a secondary zone acquisition time is recent enough, this means that "
"NSD can start serving a zone immediately on loading, without querying the"
" primary server."
msgstr ""

#: ../../source/running/zone-expiry.rst:23
msgid ""
"If your secondary zone has expired and no primaries can be reached, but "
"you still want NSD to serve the zone, then you can delete the "
":file:`xfrd.state` file, but leave the zone file for the zone intact. "
"Make sure to stop NSD before you delete the file, as NSD writes it on "
"exit. Upon loading NSD will treat the zone file that you as operator have"
" provided as recent and will serve the zone. Even though NSD will start "
"to serve the zone immediately, the zone will expire after the timeout is "
"reached again. NSD will also attempt to confirm that you have provided "
"the correct data by polling the primaries. So when the primary servers "
"come back up, it will transfer the updated zone within <retry timeout "
"from SOA> seconds."
msgstr ""

#: ../../source/running/zone-expiry.rst:34
msgid ""
"In general it is possible to provide zone files for both primary and "
"secondary zones manually (say from email or rsync). Reload with SIGHUP or"
" :command:`nsd-control reload` to read the new zone file contents into "
"the name database. When this is done the new zone will be served. For "
"primary zones, NSD will issue notifications to all configured ``notify:``"
" targets. For secondary zones the above happens; NSD attempts to validate"
" the zone from the primary (checking its SOA serial number)."
msgstr ""

